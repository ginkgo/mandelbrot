#version 430

layout (local_size_x = 64) in;

const float infinity = 999999999999.0;

uniform uint batch_size;
uniform uint batch_offset;

uniform mat4 mv;
uniform mat4 proj;
uniform mat3 screen_matrix;

uniform vec3 screen_min;
uniform vec3 screen_max;

uniform float split_limit;

uniform samplerBuffer patches;

// Patch range stack arrays
layout (std430) buffer stack_min
{
    vec2 smin[];
};

layout (std430) buffer stack_max
{
    vec2 smax[];
};

layout (std430) buffer stack_pid
{
    uint spid[];
};

// Array of packed flags
// first component is set to 1 if patch is split
// second component is set to 1 if patch is drawn
layout (std430) buffer flag_pad
{
    uvec2 fpad[];
};

// Pads for placing split patches 

layout (std430) buffer split_pad_pid
{
    uint sp_pid[];
};

layout (std430) buffer split_pad1_min
{
    vec2 sp1_min[];
};

layout (std430) buffer split_pad1_max
{
    vec2 sp1_max[];
};

layout (std430) buffer split_pad2_min
{
    vec2 sp2_min[];
};

layout (std430) buffer split_pad2_max
{
    vec2 sp2_max[];
};

vec3 eval_patch(vec2 t, int patch_id)
{
    vec2 s = 1 - t;

    mat4 B = outerProduct(vec4(s.x*s.x*s.x, 3*s.x*s.x*t.x, 3*s.x*t.x*t.x, t.x*t.x*t.x),
                          vec4(s.y*s.y*s.y, 3*s.y*s.y*t.y, 3*s.y*t.y*t.y, t.y*t.y*t.y));                          
    
    vec3 sum = vec3(0,0,0);
    for (int u = 0; u < 4; ++u) {
        for (int v = 0; v < 4; ++v) {
            sum += B[v][u] * texelFetch(patches, u + v * 4 + patch_id * 16).xyz;
        }
    }

    return sum;
}

bool intersects (vec3 min1, vec3 max1, vec3 min2, vec3 max2)
{
    return all(lessThan(min1, max2)) && all(lessThan(min2, max1));
}

void do_vsplit(uint bid, vec2 pmin, vec2 pmax, uint pid)
{
    float c = mix(pmin.y, pmax.y, 0.5);

    sp_pid[bid] = pid;

    sp1_min[bid] = pmin;
    sp1_max[bid] = vec2(pmax.x, c);

    sp2_min[bid] = vec2(pmin.x, c);
    sp2_max[bid] = pmax;
}

void do_hsplit(uint bid, vec2 pmin, vec2 pmax, uint pid)
{
    float c = mix(pmin.x, pmax.x, 0.5);

    sp_pid[bid] = pid;

    sp1_min[bid] = pmin;
    sp1_max[bid] = vec2(c, pmax.y);

    sp2_min[bid] = vec2(c, pmin.y);
    sp2_max[bid] = pmax;
}

void main (void)
{
    uint bid = gl_GlobalInvocationID.x;
    uint sid = bid + batch_offset;

    if (bid >= batch_size) return;
    
    int rpid = int(spid[sid]);
    vec2 rmin = smin[sid];
    vec2 rmax = smax[sid];
    
    vec3 pmin = vec3( infinity);
    vec3 pmax = vec3(-infinity);
    vec3 ppmin = vec3( infinity);
    vec3 ppmax = vec3(-infinity);

    vec3 ppos[4][4];
    bool row_homogeneous = true;
    
    for (int v = 0; v < 4; ++v) {
        int zrc = 0;
        for (int u = 0; u < 4; ++u) {
            vec2 lt = vec2(u / 3.0, v / 3.0);
            vec4 p = mv * vec4(eval_patch(mix(rmin,rmax,lt), rpid),1);
            
            pmin = min(p.xyz, pmin);
            pmax = max(p.xyz, pmax);            
            
            vec4 pp = proj * p;

            ppos[v][u] = screen_matrix * (pp.xyz / pp.w);

            ppmin = min(ppos[v][u], ppmin);
            ppmax = max(ppos[v][u], ppmax);
        }
    }

    uvec2 flag;
    bool vsplit;
    
    if (ppmin.z >= 1 || ppmax.z <= -1) {
        flag = uvec2(0,0); // CULL
    } else if (pmin.z < 0 && pmax.z > 0) {
        flag = uvec2(0,0); // CULL (for now)
    } else if (!intersects(ppmin, ppmax, screen_min, screen_max)) {
        flag = uvec2(0,0); // CULL
    } else {
        float hlen = 0;
        float vlen = 0;
        for (int i = 0; i < 4; ++i) {
            float ht = 0;
            float vt = 0;
            for (int j = 0; j < 3; ++j) {
                ht += distance(ppos[i][j].xy, ppos[i][j+1].xy);
                vt += distance(ppos[j][i].xy, ppos[j+1][i].xy);
            }
            
            hlen = max(ht, hlen);
            vlen = max(vt, vlen);
        }

        if (hlen <= split_limit && vlen <= split_limit) {
            flag = uvec2(0,1); // DRAW
        } else {
            flag = uvec2(1,0); // SPLIT
            vsplit = hlen < vlen;
        }
    }

    fpad[bid] = flag;
    
    if (flag == uvec2(1,0)) {
        if (vsplit) {
            do_vsplit(bid, rmin, rmax, rpid);
        } else {
            do_hsplit(bid, rmin, rmax, rpid);
        }
    }
            
}
