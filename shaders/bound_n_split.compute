#version 430

layout (local_size_x = 64) in;


#line 1
@include <utility.h>
#line 1
@include <bound_n_split.h>
#line 10

uniform uint batch_size;
uniform uint batch_offset;

// Patch range stack arrays
layout (std430) buffer stack_min
{
    vec2 smin[];
};

layout (std430) buffer stack_max
{
    vec2 smax[];
};

// 8 MSB: stack depth
// 24 LSB: patch id
layout (std430) buffer stack_pid
{
    uint spid[];
};

// Array of packed flags
// first component is set to 1 if patch is split
// second component is set to 1 if patch is drawn
layout (std430) buffer flag_pad
{
    uvec2 fpad[];
};

// Pads for placing split patches 

layout (std430) buffer split_pad_pid
{
    uint sp_pid[];
};

layout (std430) buffer split_pad1_min
{
    vec2 sp1_min[];
};

layout (std430) buffer split_pad1_max
{
    vec2 sp1_max[];
};

layout (std430) buffer split_pad2_min
{
    vec2 sp2_min[];
};

layout (std430) buffer split_pad2_max
{
    vec2 sp2_max[];
};


void do_vsplit(uint bid, vec2 pmin, vec2 pmax, uint pid, uint depth)
{
    float c = mix(pmin.y, pmax.y, 0.5);

    sp_pid[bid] = pid | (depth << 24);

    sp1_min[bid] = pmin;
    sp1_max[bid] = vec2(pmax.x, c);

    sp2_min[bid] = vec2(pmin.x, c);
    sp2_max[bid] = pmax;
}

void do_hsplit(uint bid, vec2 pmin, vec2 pmax, uint pid, uint depth)
{
    float c = mix(pmin.x, pmax.x, 0.5);

    sp_pid[bid] = pid | (depth << 24);

    sp1_min[bid] = pmin;
    sp1_max[bid] = vec2(c, pmax.y);

    sp2_min[bid] = vec2(c, pmin.y);
    sp2_max[bid] = pmax;
}


void main (void)
{
    uint bid = gl_GlobalInvocationID.x;
    uint sid = bid + batch_offset;

    if (bid >= batch_size) return;
    
    uint rpid = spid[sid] & 0xffffff;
    uint rdepth = spid[sid] >> 24;
    vec2 rmin = smin[sid];
    vec2 rmax = smax[sid];

    uint bound_flag = bound(rpid, rmin, rmax, rdepth);

    fpad[bid] = uvec2((bound_flag>>1)&1, (bound_flag>>0)&1);

    if ((bound_flag & 2) != 0) {
        if ((bound_flag & 4) != 0) {
            do_vsplit(bid, rmin, rmax, rpid, rdepth+1);
        } else {
            do_hsplit(bid, rmin, rmax, rpid, rdepth+1);
        }
    }
    
    // vec3 pmin = vec3( infinity);
    // vec3 pmax = vec3(-infinity);

    // vec2 ppos[4][4];
    
    // for (int v = 0; v < 4; ++v) {
    //     for (int u = 0; u < 4; ++u) {
    //         vec2 lt = vec2(u / 3.0, v / 3.0);
    //         vec4 p = mv * vec4(eval_patch(mix(rmin,rmax,lt), int(rpid)),1);
            
    //         pmin = min(p.xyz, pmin);
    //         pmax = max(p.xyz, pmax);            
            
    //         vec4 pp = proj * p;
    //         ppos[v][u] = mat2(screen_matrix) * (pp.xy / pp.w);
    //     }
    // }

    // uvec2 flag;
    // bool vsplit;
    
    // if (!intersects_frustum(pmin, pmax)) {
    //     flag = uvec2(0,0); // CULL
    // } else if (pmin.z < 0 && pmax.z > 0) {
    //     if (rdepth < max_split_depth-1) {
    //         flag = uvec2(1,0); // SPLIT
    //         // Pick split direction from parameter space
    //         vsplit = (rmax.x - rmin.x) < (rmax.y - rmin.y);
    //     } else { 
    //         // Max split depth reached
    //         flag = uvec2(0,1); // CULL
    //     }
    // } else {
    //     float hlen = 0;
    //     float vlen = 0;
    //     for (int i = 0; i < 4; ++i) {
    //         float ht = 0;
    //         float vt = 0;
    //         for (int j = 0; j < 3; ++j) {
    //             ht += distance(ppos[i][j].xy, ppos[i][j+1]);
    //             vt += distance(ppos[j][i].xy, ppos[j+1][i]);
    //         }
            
    //         hlen = max(ht, hlen);
    //         vlen = max(vt, vlen);
    //     }

    //     if (hlen <= split_limit && vlen <= split_limit) {
    //         flag = uvec2(0,1); // DRAW
    //     } else if (rdepth >= max_split_depth-2) {
    //         // Max split depth reached
    //         flag = uvec2(0,1); // CULL
    //     } else {
    //         flag = uvec2(1,0); // SPLIT
    //         vsplit = hlen < vlen;
    //     }
    // }

    // fpad[bid] = flag;
    
    // if (flag == uvec2(1,0)) {
    //     if (vsplit) {
    //         do_vsplit(bid, rmin, rmax, rpid, rdepth+1);
    //     } else {
    //         do_hsplit(bid, rmin, rmax, rpid, rdepth+1);
    //     }
    // }
            
}
