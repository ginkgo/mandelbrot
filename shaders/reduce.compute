#version 430

layout (local_size_x = 64) in;

uniform uint batch_size;

layout (std430) buffer input_buffer
{
    ivec2 ibuf[];
};

layout (std430) buffer output_buffer
{
    ivec2 obuf[];
};

layout (std430) buffer reduced_buffer
{
    ivec2 rbuf[];
};

shared ivec2 tbuf[128];

void main (void)
{

    uint lid = gl_LocalInvocationID.x;
    uint wid = gl_WorkGroupID.x;
    uint gid1 = wid*128 + lid;
    uint gid2 = wid*128 + 64 + lid;    

    tbuf[lid] = ivec2(0);
    tbuf[lid+64] = ivec2(0);

    // read input data into shared buffer
    if (gid1 < batch_size) tbuf[lid]    = ibuf[gid1];
    if (gid2 < batch_size) tbuf[lid+64] = ibuf[gid2];

    // up-sweep
    for (uint i = 1; i <= 64; i <<= 1) {
        memoryBarrierShared();
        
        if (lid < 64/i) {
            uint ai = (2*lid+1)*i-1;
            uint bi = (2*lid+2)*i-1;
            tbuf[bi] += tbuf[ai];
        }
    }

    // down-sweep
    for (uint i = 64; i >= 2; i >>= 1) {
        memoryBarrierShared();
                                                \
        if (lid < 128/i-1) {
            uint ai = i*(lid+1)-1;
            uint bi = ai + i/2;

            tbuf[bi] += tbuf[ai];
        }
    }

    // write results back
    memoryBarrierShared();
    if (gid1 < batch_size) obuf[gid1] = tbuf[lid];
    if (gid2 < batch_size) obuf[gid2] = tbuf[lid+64];

    rbuf[wid] = tbuf[127];    
}

#ifdef KNTZKNRFL
/*
 * Work-efficient compute implementation of scan, one thread per 2 elements
 * O(log(n)) stepas and O(n) adds using shared memory
 * Uses a balanced tree algorithm. See Belloch, 1990 "Prefix Sums
 * and Their Applications"
 * @param output	output data 
 * @param input		input data
 * @param block		local memory used in the kernel
 * @param length	lenght of the input data
 * @param idxOffset	offset between two consecutive index.
 */
__kernel 
void group_prefixSum(__global float * output,
					 __global float * input,
					 __local  float * block,
					 const uint length,
					 const uint idxOffset) {
	int localId = get_local_id(0);
	int localSize = get_local_size(0);
	int globalIdx = get_group_id(0);

	// Cache the computational window in shared memory
	globalIdx = (idxOffset *(2 *(globalIdx*localSize + localId) +1)) - 1;
	if(globalIdx < length)             { block[2*localId]     = input[globalIdx];				}
    if(globalIdx + idxOffset < length) { block[2*localId + 1] = input[globalIdx + idxOffset];	}

	// Build up tree 
	int offset = 1;
	for(int l = length>>1; l > 0; l >>= 1) {
        barrier(CLK_LOCAL_MEM_FENCE);
        if(localId < l) {
            int ai = offset*(2*localId + 1) - 1;
            int bi = offset*(2*localId + 2) - 1;
            block[bi] += block[ai];
        }
        offset <<= 1;
    }

	if(offset < length) { offset <<= 1; }

	// Build down tree
	int maxThread = offset>>1;
	for(int d = 0; d < maxThread; d<<=1){
        d += 1;
        offset >>=1;
        barrier(CLK_LOCAL_MEM_FENCE);

        if(localId < d) {
            int ai = offset*(localId + 1) - 1;
            int bi = ai + (offset>>1);
            block[bi] += block[ai];
        }
    }
	barrier(CLK_LOCAL_MEM_FENCE);

    // write the results back to global memory
    if(globalIdx < length)           { output[globalIdx]             = block[2*localId];		}
    if(globalIdx+idxOffset < length) { output[globalIdx + idxOffset] = block[2*localId + 1];	}
}
#endif
